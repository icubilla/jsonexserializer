Collections are pretty inconsistent in the .NET framework.  For more info on this see [http://blogs.msdn.com/madst/archive/2006/10/10/What-is-a-collection_3F00_.aspx here].
The problem is you have ICollection, which is great for iterating over, but it doesn't have an Add method, so you can't deserialize the collection using the ICollection interface.  IList does have an add method, but not everything implements IList.  Classes like Stack, Queue don't implement IList.  .NET 2.0 brought us ICollection<T> which does have add, but again not everything implements it.

So here's the solution: ICollectionHandler and ICollectionBuilder.
The ICollectionHandler interface has methods for checking if a given collection type can be handled.  If a type implementing ICollectionHandler can handle your collection type, it can return an ICollectionBuilder object.  The ICollectionBuilder interface has an add method that knows how to put things into the collection and a GetResult method that returns the final collection.

The following collection types are handled automatically:
  # Arrays of any type
  # System.Collections.IList
  # System.Collections.Generic.ICollection<T>
  # Anything implementing ICollection that also has a constructor that takes a single parameter of type ICollection, ICollection<T>, IEnumerable, or IEnumerable<T>.
  # All collection types in System.Collections and System.Collections.Generic namespaces.

If your collection type does not fit into one of those cases, you can implement an ICollectionHandler for it.  Then register that handler with the SerializationContext parameter.

Example:
{{{
public class MyCollectionHandler : ICollectionHandler {
   public bool IsCollection(Type collectionType) {
      if (collectionType == typeof(MyCollection)) {
          return true;
      }
      else 
      {
          return false;
      }
   }
   
   public ICollectionBuilder ConstructBuilder(Type collectionType) {
      return new MyCollectionBuilder();
   }

   // return the type of items contained in the collection
   public Type GetItemType(Type collectionType) {
      return typeof(object);
   }

   public IEnumerable GetEnumerable(object collection) {
      // assuming your object implements IEnumerable
      return collection;
   }
}

public class MyCollectionBuilder : ICollectionBuilder {
   private MyCollection _instance;

   public MyCollectionBuilder() {
      _instance = new MyCollection();
   }

   public void Add(object item) {
      _instance.MyAdd(item);
   }

   public object GetResult() {
      return _instance;
   }
}

...
Serializer s = Serializer.GetSerializer(typeof(MyCollection));
s.Context.RegisterCollectionHandler(new MyCollectionHandler());

}}}